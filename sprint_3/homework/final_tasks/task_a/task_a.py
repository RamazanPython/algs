# ID - 100974008
# Time: O(logN)
# Space: O(1) - no extra data structure
"""
Прицнип работы

Нам дан отсортированный сдвинутый массив. Нам нужно найти элемент за O(logN). Это говорит нам о том, что нужно
использовать бинарный поиск.

Что такое отсортированный массив (не важно по убыванию или возрастанию) вида [a1, a2..., an]. Это значит каждый
последующий элемент в массиве больше или равен (или меньше или равен) предыдущему элементу. => последний элемент всегда
больше или равен (или меньше или равен) первому элементу. За счет этого в бинарном поиске мы можем брать центральный
элемент массива и сравнивать с искомым и понимать, в какой части массива находится искомый элемент (если центральный
не равен искомому). Здесь и далее под отсортированном массивом мы подразумеваем сортировку по возрастанию.

В сдвинутом массиве это условие не соблюдается. То есть an может быть меньше a1 (последний может быть меньше первого).
Но сдвинутый массив в отличие от полностью неотсортированного массива мы можем разбить на 2 отсортированные части!
Поэтому нам нужно модифицировать бинарный поиск с этим учетом. Так же есть еще одно важное замечание: при любом разбиении
сдвинутого массива на две части одна из этих частей точно будет отсортированной. => Главное свойство сдвинутого массива:
    1. При любом разбиении сдвинутого массива как минимум одна из частей будет отсортированной.

С этим учетом мы можем модифицировать двоичный пооиск. Для примера возьмем следующий массив:
    a = [10, 11, 12, 13, 1, 2, 3, 4]

Искомый элемент target = 3. Левая граница left = 0, правая граница right = len(a) - 1.

Как найти индекс элемента 3? Как и двоичном поиске возьмем центральный элемент. К примеру, a[mid] = 13. Держим в голове
главное свойство сдвинутого массива. Нам нужно понять, находимся ли мы в отсортированной части или нет. Сравниваем
центральный элемент с первым элементом:
    a[mid] > a[0] (13 > 10)

=> элементы от начала до mid отсортированы. Далее нам нужно сравнивать наш искомый элелмент с первым.

    target < a[left] (3 < 10)

=> Нам нужно сдвинуть левую границу на mid + 1. Но является ли это единственным условием сдвига левой границу? Если бы
target = 12. У нас выходит, что
    a[mid] > a[left] и target < a[left]

Что это нам говорит? Нам нужно сдвинуть правую границу на mid - 1.

Теперь посмотрим на ситуацию когда a[left] > a[mid]. Возьмем все тот же массив, a[mid] = 1, target = 3.
    a[mid] < a[left].

Это нам говорит о том, что от начала массива до a[mid - 1] элементы больше чем от a[mid] до конца. Сравниваем
target с крайней правым элементом:
    target < a[right]

=> значит искомый элемент находится от mid + 1 до right. Если бы target = 12 и a[mid] = 1, то у нас было бы следующее
условие:
    a[left] > a[mid] и target > a[right]

=> Сдвигаем правую границу right = mid - 1.

"""


def broken_search(nums: list[int], target: int) -> int:
    left = 0
    right = len(nums) - 1

    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid

        if nums[mid] >= nums[left]:
            if nums[left] <= target <= nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] <= target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1

    return -1


def test():
    arr = [19, 21, 100, 101, 1, 4, 5, 7, 12]
    assert broken_search(arr, 5) == 6
